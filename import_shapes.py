# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ImportShapes
                                 A QGIS plugin
 Импорт шейпов в базу
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-31
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Ruslan Shamsutdinov
        email                : test@test.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication,QThread,pyqtSignal
from qgis.PyQt.QtGui import QIcon,QPixmap
from qgis.PyQt.QtWidgets import QAction,QMessageBox,QTableWidgetItem,QPushButton
from qgis.PyQt.QtSql import *
from qgis.core import QgsVectorLayer,QgsField,QgsFields

import re

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .import_shapes_dialog import ImportShapesDialog
from .postgis_connection_info_dialog import PostgisConnectionInfoDialog
from .file_info_dialog import FileInfoDialog
import os.path

class ProgressThread(QThread):
    update_message = pyqtSignal(str)
    progress_update = pyqtSignal(int)
    progress_max = pyqtSignal(int)
    twFiles = None
    user = ""
    password = ""
    port = ""
    host = ""
    
    def __init__(self):
        QThread.__init__(self)
    
    def run(self):
        for i in range(self.twFiles.rowCount()):
            j = 1
            database = self.twFiles.item(i,0).text()
            table = self.twFiles.item(i,1).text()
            districtForesty = self.twFiles.item(i,2).text()
            filePath = self.twFiles.item(i,3).text()
            layer = QgsVectorLayer(filePath,"tmpLayer","ogr")
            srid = self.twFiles.item(i,4).text()
            districtForestyGuid = self.twFiles.item(i,6).text()
            quartColumn = self.twFiles.item(i,7).text()
            taxColumn = self.twFiles.item(i,8).text()
            self.update_message.emit(u"------------------------------------------------")
            if(layer.isValid()):
                self.update_message.emit(u"Файл исправен.")
                self.update_message.emit(u"Начинаю перенос геометрии из файла %s, в базу %s, в таблицу %s" % (filePath,database,table))
                db = self.getCustomConnection(database,self.host,self.port,self.user,self.password)
                self.progress_max.emit(layer.featureCount())
                if(db.open()):
                    if(table=="t_taxationisolated"):
                        for feature in layer.getFeatures():
                            #print("update t_taxationisolated set shape=ST_GeomFromText('{shape}',{srid}) from t_forestquarter where t_taxationisolated.forestquarter =t_forestquarter.primarykey and t_taxationisolated.number={taxNumber} and t_forestquarter.number={quartNumber} and t_forestquarter.forestdistrict = '{districtForesty}'".format(shape=feature.geometry().asWkt(),srid=srid,taxNumber=feature[taxColumn],quartNumber=feature[quartColumn],districtForesty=districtForestyGuid))
                            db.exec_("update t_taxationisolated set shape=ST_GeomFromText('{shape}',{srid}),centroid_shape=ST_GeomFromText('{centroid}',{srid}) from t_forestquarter where t_taxationisolated.forestquarter =t_forestquarter.primarykey and t_taxationisolated.number={taxNumber} and t_forestquarter.number={quartNumber} and t_forestquarter.forestdistrict = '{districtForesty}'".format(shape=feature.geometry().asWkt(),srid=srid,taxNumber=feature[taxColumn],quartNumber=feature[quartColumn],districtForesty=districtForestyGuid,centroid=feature.geometry().centroid().asWkt()))
                            self.progress_update.emit(j)
                            j=j+1
                        self.update_message.emit(u"Создаю геометрию кварталов по геометрии выделов")
                        #print("update t_forestquarter set shape = fq.shape, centroid_shape=ST_centroid(fq.shape) from(select st_union(case when st_isvalid(t_taxationisolated.shape)then shape else st_makevalid(t_taxationisolated.shape) end) as shape,t_taxationisolated.forestquarter from t_taxationisolated inner join t_forestquarter on t_taxationisolated.forestquarter=t_forestquarter.primarykey and t_forestquarter.forestdistrict = '{districtForesty}' where shape is not null group by forestquarter ) as fq where fq.forestquarter = t_forestquarter.primarykey".format(districtForesty=districtForestyGuid))
                        db.exec_("update t_forestquarter set shape = fq.shape, centroid_shape=ST_centroid(fq.shape) from(select st_union(case when st_isvalid(t_taxationisolated.shape)then t_taxationisolated.shape else st_makevalid(t_taxationisolated.shape) end) as shape,t_taxationisolated.forestquarter from t_taxationisolated inner join t_forestquarter on t_taxationisolated.forestquarter=t_forestquarter.primarykey and t_forestquarter.forestdistrict = '{districtForesty}' where t_taxationisolated.shape is not null group by forestquarter ) as fq where fq.forestquarter = t_forestquarter.primarykey".format(districtForesty=districtForestyGuid))
                        self.update_message.emit(u"Импорт прошел успешно!")
                    elif(table=="t_forestquarter"):
                        for feature in layer.getFeatures():
                            #print("update t_taxationisolated set shape=ST_GeomFromText('{shape}',{srid}) from t_forestquarter where t_taxationisolated.forestquarter =t_forestquarter.primarykey and t_taxationisolated.number={taxNumber} and t_forestquarter.number={quartNumber} and t_forestquarter.forestdistrict = '{districtForesty}'".format(shape=feature.geometry().asWkt(),srid=srid,taxNumber=feature[taxColumn],quartNumber=feature[quartColumn],districtForesty=districtForestyGuid))
                            db.exec_("update t_forestquarter set shape=ST_GeomFromText('{shape}',{srid}),centroid_shape=ST_GeomFromText('{centroid}',{srid}) where t_forestquarter.number={quartNumber} and t_forestquarter.forestdistrict = '{districtForesty}'".format(shape=feature.geometry().asWkt(),srid=srid,quartNumber=feature[quartColumn],districtForesty=districtForestyGuid,centroid=feature.geometry().centroid().asWkt()))
                            self.progress_update.emit(j)
                            j=j+1
                        self.update_message.emit(u"Импорт прошел успешно!")
                else:
                    self.update_message.emit(u"Ошибка при подключении к базе %s:" % database)
                    self.update_message.emit(db.lastError().text())
                    self.update_message.emit("")
                db.close()
            else:
                self.update_message.emit("Ошибка в файле!!!")
    
    def getCustomConnection(self,dbName,host,port,user,password):
        db = QSqlDatabase.addDatabase("QPSQL")
        db.setDatabaseName(dbName)
        db.setHostName(host)
        db.setPort(int(port))
        db.setUserName(user)
        db.setPassword(password)
        return db    
    
    
    def stop(self):
        self.runBool=False
    
    def __del__(self):
        self.wait()

class ImportShapes:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ImportShapes_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Import shapes')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ImportShapes', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/import_shapes/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Import shapes'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Import shapes'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ImportShapesDialog()
            self.pgConnDlg = PostgisConnectionInfoDialog()
            self.progressThread = ProgressThread()
            self.initializeInterfaceMainDialog()
            self.initializeSignals()
        # show the dialog
        self.dlg.show()
        self.dlg.pbrImport.setVisible(False)
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        self.progressThread.quit()
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        
            
    #Кастомные методы
    def initializeInterfaceMainDialog(self):
        self.dlg.twFiles.setRowCount(0)
        self.dlg.twFiles.setColumnHidden(6,True)
        self.dlg.twFiles.setColumnHidden(7,True)
        self.dlg.twFiles.setColumnHidden(8,True)
    
    def initFileDialog(self):
        self.fileInfoDlg = FileInfoDialog()
        self.fileInfoDlg.cbTypeOfData.currentIndexChanged.connect(self.cbTypeOfData_currentIndexChanged)
        self.fileInfoDlg.mQgsFileWidget.fileChanged.connect(self.mQgsFileWidget_fileChanged)
    
    def initializeSignals(self):
        self.dlg.pbAddFile.clicked.connect(self.pbAddFile_Clicked)
        self.dlg.pbConnectInfo.clicked.connect(self.pbConnectInfo_Clicked)
        self.dlg.twFiles.cellClicked.connect(self.twFiles_cellClicked)
        self.dlg.pbImport.clicked.connect(self.pbImport_clicked)
        self.progressThread.progress_update.connect(self.updateProgressBar)
        self.progressThread.progress_max.connect(self.updateProgressBarMaxValue)
        self.progressThread.update_message.connect(self.appendMessageInLog)
        self.progressThread.finished.connect(self.importThreadFinished)
        self.dlg.pbCancel.clicked.connect(self.pbCancel_clicked)
    
    def getConnection(self):
        db = QSqlDatabase.addDatabase("QPSQL")
        db.setDatabaseName(self.pgConnDlg.lnedDataBase.text())
        db.setHostName(self.pgConnDlg.lnedHost.text())
        db.setPort(int(self.pgConnDlg.lnedPort.text()))
        db.setUserName(self.pgConnDlg.lnedUserName.text())
        db.setPassword(self.pgConnDlg.lnedPassword.text())
        if(db.open()):
            db.close()
            return db
        else:
            self.dlg.textEditLogMsg.append(u"Ошибка при подключении к базе %s:" % self.pgConnDlg.lnedDataBase.text())
            self.dlg.textEditLogMsg.append(db.lastError().text())
            self.dlg.textEditLogMsg.append("")
            return None

   
    #Слоты
    def importThreadFinished(self):
        self.dlg.pbrImport.setVisible(False)
        
    def appendMessageInLog(self,msg):
        self.dlg.textEditLogMsg.append(msg)
   
    def updateProgressBarMaxValue(self,maxValue):
        self.dlg.pbrImport.setMaximum(maxValue)
   
    def updateProgressBar(self,value):
        self.dlg.pbrImport.setValue(value)
        
    def pbCancel_clicked(self):
        if(self.progressThread.isRunning()):
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText(u"В данный момент импортируются данные из файлов.\nПрервать выполнение?")
            msgBox.setWindowTitle(u"Предупреждение")
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            result = msgBox.exec_()
            if result == QMessageBox.Ok:
                self.progressThread.terminate()
        else:
            self.dlg.done(0)
         
    
    def pbImport_clicked(self):
        self.dlg.pbrImport.setValue(0)
        self.dlg.pbrImport.setVisible(True)
        #print("progress",self.progressThread.isRunning())
        if(self.progressThread.isRunning()):
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText(u"В данный момент импортируются данные из файлов.\nПрервать выполнение?")
            msgBox.setWindowTitle(u"Предупреждение")
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            result = msgBox.exec_()
            if result == QMessageBox.Ok:
                self.progressThread.terminate()
        else:
            self.progressThread.twFiles = self.dlg.twFiles
            self.progressThread.user = self.pgConnDlg.lnedUserName.text()
            self.progressThread.password = self.pgConnDlg.lnedPassword.text()
            self.progressThread.port = self.pgConnDlg.lnedPort.text()
            self.progressThread.host = self.pgConnDlg.lnedHost.text()
            self.progressThread.start()

        #self.dlg.pbrImport.setVisible(False)    
        
    
    def twFiles_cellClicked(self,row,column):
        if(column==5):
            if(self.dlg.twFiles.item(row,column).checkState()==2):
                self.dlg.twFiles.removeRow(row)
                
    def mQgsFileWidget_fileChanged(self):
        layer = QgsVectorLayer(self.fileInfoDlg.mQgsFileWidget.filePath(),"tmpLayer","ogr")
        self.fileInfoDlg.cbQuartNumber.clear()
        self.fileInfoDlg.cbTaxNumber.clear()
        if(layer.isValid()):
            for field in layer.fields():
                self.fileInfoDlg.cbQuartNumber.addItem(QIcon(),field.name(),field.name())
                self.fileInfoDlg.cbTaxNumber.addItem(QIcon(),field.name(),field.name())
        
    def pbAddFile_Clicked(self):
        db = self.getConnection()
        if(db != None):
            self.initFileDialog()
            db.open()
            query = db.exec_("select primarykey,name from t_foresty where hierarchy is not null order by name")
            districtForesties = []
            while(query.next()):
                self.fileInfoDlg.cbDistrictForesties.addItem(QIcon(),query.value(1),query.value(0))
            self.fileInfoDlg.show()
            result = self.fileInfoDlg.exec_()
            if result:
                typeOfShapeFile = ""
                if self.fileInfoDlg.cbTypeOfData.currentText() == 'Выделы':
                    typeOfShapeFile="t_taxationisolated"
                elif self.fileInfoDlg.cbTypeOfData.currentText() == 'Кварталы':
                    typeOfShapeFile="t_forestquarter"
                self.dlg.twFiles.insertRow(self.dlg.twFiles.rowCount())
                dataBaseItem = QTableWidgetItem(self.pgConnDlg.lnedDataBase.text())
                dataBaseItem.setFlags(QtCore.Qt.ItemIsEnabled)
                typeOfShpItem = QTableWidgetItem(typeOfShapeFile)
                typeOfShpItem.setFlags(QtCore.Qt.ItemIsEnabled)
                dfItem = QTableWidgetItem(self.fileInfoDlg.cbDistrictForesties.currentText())
                dfItem.setFlags(QtCore.Qt.ItemIsEnabled)
                fileItem = QTableWidgetItem(self.fileInfoDlg.mQgsFileWidget.filePath())
                fileItem.setFlags(QtCore.Qt.ItemIsEnabled)
                rmItem = QTableWidgetItem()
                rmItem.setCheckState(QtCore.Qt.Unchecked)
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,0,dataBaseItem)
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,1,typeOfShpItem)
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,2,dfItem)
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,3,fileItem)
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,4,QTableWidgetItem("0"))
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,5,rmItem)
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,6,QTableWidgetItem(self.fileInfoDlg.cbDistrictForesties.itemData(self.fileInfoDlg.cbDistrictForesties.currentIndex())))
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,7,QTableWidgetItem(self.fileInfoDlg.cbQuartNumber.currentText()))
                self.dlg.twFiles.setItem(self.dlg.twFiles.rowCount()-1,8,QTableWidgetItem(self.fileInfoDlg.cbTaxNumber.currentText()))
            db.close()
        else:
            QMessageBox.warning(None,u"Предупреждение",u"Не удалось подключиться к базе.\nПроверьте данные для подключения к базе.")
            
    def pbConnectInfo_Clicked(self):
        self.pgConnDlg.show()
        result = self.pgConnDlg.exec_()
        if result:
            self.dlg.textEditLogMsg.append(u"Подключение:")
            self.dlg.textEditLogMsg.append(u"сервер=%s, порт=%s, база данных=%s" % (self.pgConnDlg.lnedHost.text(),self.pgConnDlg.lnedPort.text(),self.pgConnDlg.lnedDataBase.text()))
            self.dlg.textEditLogMsg.append(u"имя пользователя=%s, пароль=%s\n" % (self.pgConnDlg.lnedUserName.text(),"********"))
            
    def cbTypeOfData_currentIndexChanged(self,idx):
        if self.fileInfoDlg.cbTypeOfData.currentText() == 'Выделы':
            self.fileInfoDlg.lblTaxNumber.setVisible(True)
            self.fileInfoDlg.cbTaxNumber.setVisible(True)
        elif self.fileInfoDlg.cbTypeOfData.currentText() == 'Кварталы':
            self.fileInfoDlg.lblTaxNumber.setVisible(False)
            self.fileInfoDlg.cbTaxNumber.setVisible(False)
            
            